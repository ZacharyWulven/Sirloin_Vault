---
layout: post
title: 鸿蒙开发-03
date: 2024-08-26 16:45:30.000000000 +09:00
categories: [ArkTS]
tags: [ArkTS]
---


## 线性布局
### 线性布局（LinearLayout）：通过线性容器 `Column` 和 `Row` 创建
  - `Column` 容器: 子元素垂直方法排列布局
  - `Row` 容器: 子元素水平方向排列布局
  
### 排布主轴（主方向）上的对齐方式
  - 属性 `.justifyContent`（枚举 FlexAlign）
  

![image](/assets/img/harmony/justify.png)

* 下边为 `Column` 组件代码，`Row` 组件同理

```typescript
@Entry
@Component
struct Index {
  build() {
    Column() {
      Text()
        .height(200) // 单位是 vp
        .width(300)  // 单位是 vp
        .backgroundColor(Color.Pink)
        .border({ width: 2})

      Text()
        .height(200) // 单位是 vp
        .width(300)  // 单位是 vp
        .backgroundColor(Color.Pink)
        .border({ width: 2})

      Text()
        .height(200) // 单位是 vp
        .width(300)  // 单位是 vp
        .backgroundColor(Color.Pink)
        .border({ width: 2})
    }
    .width('100%')
    .height('100%')
    /*
        设置主方向对齐方式
        justifyCOntent(枚举flexalign)
        1. Start 排布主方向，主轴起始位置对齐
        2. Center 主轴居中对齐
        3. End 主轴结位置中对齐
        4. SpaceBetween first/last 子元素贴边显示，中间元素均匀分布
        5. SpaceAround  每个子元素上下都有间隙
        6. SpaceEvenly 均匀 margin
     */
    // .justifyContent(FlexAlign.Center)
    // .justifyContent(FlexAlign.SpaceBetween)
    // .justifyContent(FlexAlign.SpaceAround)
    .justifyContent(FlexAlign.SpaceEvenly)

  }
}
```

![image](/assets/img/harmony/justify1.png)


### 线性布局-主轴案例
* 分析过程：
  1. 先判断主轴，确定是 `Row 组件`
  2. 排布方向水平往右（主轴）
  3. 使用 `justifyContent` 设置主轴对齐方式
  
```typescript
@Entry
@Component
struct Index {
  build() {
    Column() {
      Row() {
        Image($r('app.media.1'))
          .width(30)
        Text('个人中心')
        Image($r('app.media.icon'))
          .width(24)
      }
      .width('100%')
      .height(40)
      .backgroundColor(Color.White)
      .justifyContent(FlexAlign.SpaceBetween) // 主轴对齐方式
      .padding({  // 添加主轴间距，让左右的 icon 不那么靠边
        left: 10,
        right: 10
      })
    }
    .width('100%')
    .height('100%')
  }
}
```


### 排布交叉轴（即与主轴垂直的轴）上的对齐方式
* 如果主轴是 `Row` 那么交叉轴就是 `Column`; Vice versa
* 交叉轴对齐方式使用：`alignItems()` 语法，参数为枚举
  - 枚举类型-水平方向：HorizontalAlign
  - 枚举类型-垂直方向：VerticalAlign


![image](/assets/img/harmony/cross.png)



```typescript
@Entry
@Component
struct Index {
  build() {
    // Column 交叉轴的对齐方式(水平往右)
    // alignItems(HorizontalAlign.Start)
    // Column() {
    //   Text()
    //     .width(200).height(100)
    //     .backgroundColor(Color.Pink)
    //     .border({width: 2})
    //   Text()
    //     .width(200).height(100)
    //     .backgroundColor(Color.Pink)
    //     .border({width: 2})
    //     .margin({top: 5, bottom: 5})
    //   Text()
    //     .width(200).height(100)
    //     .backgroundColor(Color.Pink)
    //     .border({width: 2})
    //
    // }
    // .alignItems(HorizontalAlign.End) // 水平居右
    // .width('100%')
    // .height('100%')



    // Row 交叉轴的对齐方式(垂直往下) VerticalAlign
    //   .alignItems(VerticalAlign.Center)
    Row() {
    Text()
      .width(60).height(100)
      .backgroundColor(Color.Pink)
      .border({width: 2})
    Text()
      .width(60).height(100)
      .backgroundColor(Color.Pink)
      .border({width: 2})
      .margin({left: 5, right: 5})
    Text()
      .width(60).height(100)
      .backgroundColor(Color.Pink)
      .border({width: 2})

  }
  .alignItems(VerticalAlign.Bottom) // 水平居右
  .width('100%')
  .height('100%')
}

}
```


### 线性布局-交叉轴案例

* 实现分析：
  - 整体：横行布局 `Row`
  - `Row` 主轴，两端对齐
  - 内部子元素，一个 `Column`, 一个 `Row`
  - 列的内容居左显示 `.alignItems()`

```typescript
// 交叉轴案例
@Entry
@Component
struct Index {
  build() {
    Column() {
      Row() {
        // 左侧列
        Column({ space: 8}) {
          Text('玩一玩')
            .fontSize(18)
            .fontWeight(700)
            // .margin({bottom: 5})

          Text('签到领卡 ｜ 超级好玩')
            .fontSize(18)
            .fontColor('#999')
        }
        .alignItems(HorizontalAlign.Start)

        // 右侧行
        Row({ space: 10}){
          Image($r('app.media.app_icon'))
            .width(40)
            .backgroundColor('#efefef')

          Image($r('app.media.ic_gallery_create'))
            .width(30)
            .fillColor('#888')

        }
      }
      .justifyContent(FlexAlign.SpaceBetween)
      .padding({
        left: 15, right: 15
      })
        .width('100%')
        .height(80)
        .backgroundColor('#fff')
        .borderRadius(10)


    }
    .padding(10)
    .width('100%')
    .height('100%')
    .backgroundColor('#ccc')
  }
}
```



# 组件编程技巧

## 样式复用
* 开发者可使用 @Styles 或 @Extend 装饰器将多个样式封装成一个方法

### @Styles
* 可以定义在组件内或当前文件中的全局可用
* 组件内的 @Styles 方法只能在当前组件中使用，全局的 @Styles 方法目前只允许在当前 ets 文件中使用
* 组件内的 @Styles 方法不需要声明 function 关键字，全局的 @Styles 方法需要声明 function 关键字
* @Styles 方法中只能包含通用属性和通用事件方法
* @Styles 方法不支持参数


### @Extend
* 只能定义在当前文件中的全局可用，并且只能用于`指定类型`的组件
* 可以包含指定组件的专有属性方法和专有事件方法
* 支持参数


```typescript
import promptAction from '@ohos.promptAction';

@Entry
@Component
struct Index {
  build() {
    Column({ space: 50 }) {

      Button('A')
        .compButtonStyle()
        .type(ButtonType.Normal)
        .onClick(() =>  {
          promptAction.showToast( {
            message: '服务器开小差了',
            duration: 2000,
            bottom: 50
          })
        })

      Button('B')
        .globalButtonStyle()
        .type(ButtonType.Normal)
        .onClick(() =>  {
          promptAction.showToast( {
            message: '服务器开小差了',
            duration: 2000,
            bottom: 50
          })
        })

      Button('C')
        .buttonStyle(Color.Green)
        .onClick(() =>  {
          promptAction.showToast( {
            message: '服务器开小差了',
            duration: 2000,
            bottom: 50
          })
        })


    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)
  }

  // 组件内部
  @Styles compButtonStyle() {
    .width(100)
    .height(40)
    .borderRadius(10)
    // .backgroundColor(color)  Styles 不能有参数
    // .type(ButtonType.Normal) // 只能包含公用属性
  }
}

// @Styles 当前文件中，全局可用
@Styles
function globalButtonStyle() {
  .width(100)
  .height(40)
  .borderRadius(10)
}

// @Extend 当前文件中，全局可用
@Extend(Button)
function buttonStyle(color: Color) {
  .width(100)
  .height(40)
  .borderRadius(10)
  .backgroundColor(color)
  .type(ButtonType.Normal)
}
```

## UI 结构复用
* 使用 @Builder 方法

> 文件内全局的 @Builder 支持导出，导出后可用于整个应用
{: .prompt-info }


```typescript
@Entry
@Component
struct Index {
  build() {
    Column({ space: 50}) {
      // 组件内的 @Builder 使用 this
      this.buttonBuilder($r('app.media.icon'), 'Send', () => {
        console.log('send')
      })
      
      gButtonBuilder($r('app.media.hk'), 'Good', () => console.log('good'))
    }

  }

  @Builder buttonBuilder(img: Resource, text: string, callback: ()=>void) {
    Button() {
      Row({space: 30 }) {
        Image(img)
          .width(25)
          .height(25)
        Text(text)
          .fontColor(Color.White)
          .fontSize(25)
      }
    }.width(120)
    .height(50)
    .onClick(callback)
  }

}

// 全局: 支持导出
@Builder export function gButtonBuilder(img: Resource, text: string, callback: ()=>void) {
  Button() {
    Row({space: 30 }) {
      Image(img)
        .width(25)
        .height(25)
      Text(text)
        .fontColor(Color.White)
        .fontSize(25)
    }
  }.width(120)
  .height(50)
  .onClick(callback)
}
```


### @Builder 的参数传递
* 按值传递
* 按引用传递：如果参数为状态变量，则状态变量的变化会触发 @Builder 方法内部的 UI 刷新；按值传递则不会

> 当只有一个参数，并且参数为对象字面量时；其余情况均为按值传递
{: .prompt-info }


### @Builder VS 自定义组件
* 两者都可以实现 UI 复用的效果
* 但自定义组件可以定义自己的状态变量，而 @Builder 不行


> 如果复用的 UI 结构没有状态，推荐使用 @Builder，否则使用自定义组件
{: .prompt-info }


### @BuilderParam 装饰器
* 用于装饰自定义组件中的属性，其装饰的属性可作为一个 UI 结构的占位符，
待创建该组件时，可通过参数为i其传入具体的内容
  - 其参数：必须是一个函数，并且是一个 UI 结构（@Builder 正好是）
  
* 类似于 Vue 框架中的 slot

* 如果一个组件只定义了一个 @BuilderParam 属性，那么创建该组件时，也可直接通过 `子组件` 的方式传入具体的 UI 结构


#### Code 
* 自定义组件 Card

```typescript
@Component
export struct Card {
  @BuilderParam content: () => void;

  build() {
    Column() {
      this.content()
    }
    .width('90%')
    .padding(10)
    .borderRadius(10)
    .shadow({ radius: 20})
  }

}
```

* 如何使用

```typescript
import { Card } from '../custom/Card';

@Entry
@Component
struct Index {
  @State count: number = 1;


  build() {
    Column({ space: 50}) {
      // 只有一个 @BuilderParam，通过子组件方式创建
      Card() {
        Column({space: 20}) {
          Image($r('app.media.icon'))
            .width(300)
            .height(150)
          Text('System')
        }
      }

      // 通过 @Builder 方式创建
      Card({ content: imageBuilder })

      // 组件内的 @Builder 使用 this
      valueTextBuilder(this.count)
      // 按引用传递时，需要传入包含 count 属性的对象
      referenceTextBuilder({ count: this.count })

      Row({space: 50}) {
        Button('-1')
          .onClick(() => {
            this.count--;
          })

        Button('+1')
          .onClick(() => {
            this.count++;
          })
      }

    }
    .width('100%')
    .height('100%')
    .justifyContent(FlexAlign.Center)

  }

}

@Builder function valueTextBuilder(count: number) {
  Text(`按值传递：${count}`)
    .fontSize(30)
    .fontWeight(FontWeight.Bold)
}

// 写 { count: number } 报错，这里转换一下
interface RefObj {
  count: number
}

@Builder function referenceTextBuilder(obj: RefObj) {
  Text(`按引用传递：${obj.count}`)
    .fontSize(30)
    .fontWeight(FontWeight.Bold)
}

@Builder
function imageBuilder() {
  Column({space: 20}) {
    Image($r('app.media.icon'))
      .width(300)
      .height(150)
    Text('System')
  }
}
```

## 自适应伸缩
* 设置 `layoutWeight` 属性的子元素与兄弟元素会`按照权重`进行分配`主轴`的`空间`
* 语法：`.layoutWeight(数字)` 数字是占的份数（即比例）,如果只有一个元素就是 1


![image](/assets/img/harmony/layout_weight.png)


```typescript
@Entry
@Component
struct Index {
  build() {
    Column() {
      // layoutWeight 自适应伸缩: 按照权重份数，分配剩余空间

      Row() {
        Text('左边')
          .layoutWeight(1) // 总宽度减去右边的 80 后，占 1 份
          .height(40)

        Text('中间')
          .layoutWeight(2)
          .height(40)
          .backgroundColor(Color.Green)

        Text('右边')
          .width(80).height(40)
          .backgroundColor(Color.Pink)
      }
      .backgroundColor(Color.Gray)
      .margin({bottom: 20})

      Row() {
        // 平均分布例子
        
        Text('first')
          .layoutWeight(1)
          .height(40)

        Text('second')
          .layoutWeight(1)
          .height(40)
          .backgroundColor(Color.Green)

        Text('third')
          .height(40)
          .layoutWeight(1)
          .backgroundColor(Color.Pink)
      }
      .backgroundColor(Color.Gray)
    }
    .width('100%')
    .height('100%')
    .padding(20)

  }

}
```

### 卡片 Cell 案例

```typescript
@Entry
@Component
struct Index {
  build() {
    Column() {
      Column() {
        Image($r('app.media.hk'))
          .width('100%')
          .backgroundColor('#efefef')
          .borderRadius({
            topLeft: 5,
            topRight: 5
          })

        Text('今晚吃这个 | 每日艺术分享 No.43')
          .fontSize(14)
          .fontWeight(600)
          .lineHeight(22)
          .height(60)
          .margin({
            left: 10,
            right: 10
          })

        // 底部
        Row() {
          // 头像、昵称
          Row({ space: 5}) {
            Image($r('app.media.1'))
              .width(10)
              .borderRadius(8)

            Text('插画师分享地点')
              .fontSize(10)
              .fontColor('#999')
          }
          .layoutWeight(1)

          Row({ space: 5 }) {
            Image($r('app.media.app_icon'))
              .width(12)
              .fillColor('#999')

            Text('23000')
              .fontSize(10)
              .fontColor('#666')

          }

        }
        .padding({
          left: 15,
          right: 15
        })

      }
      .width(200)
      .padding({
        bottom: 15
      })
      .backgroundColor(Color.White)
      .borderRadius(5)

    }
    .width('100%')
    .height('100%')
    .padding(20)
    .backgroundColor(Color.Gray)
  }

}
```

