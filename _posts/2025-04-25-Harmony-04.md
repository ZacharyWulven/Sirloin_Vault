---
layout: post
title: 鸿蒙开发-04
date: 2025-04-25 16:45:30.000000000 +09:00
categories: [ArkTS]
tags: [ArkTS]
---


## 组件级状态管理
* ArkTS 提供了一系列状态相关的装饰器，例如 `@State`, `@Prop`, `@Link`, `@Provide`, `@Consume`

### 1 `@State`
* 用于装饰当前组件的状态变量，`@State` 装饰变量发生变化时会驱动当前组件的视图进行刷新


```typescript
@Entry
@Component
struct Index {
  @State count: number = 1

  build() {
    Column({ space: 50 }) {
      Row({space: 10}) {
        Text('@State')

        Counter() {
          Text(this.count.toString())
        }
        .onInc(() => this.count++)
        .onDec(() => this.count--)
      }

    }
    .width('100%')
    .height('100%')
    .padding(20)   // 内边距，四边 20
    .justifyContent(FlexAlign.Center)

  }
}
```

### 2 `@Prop`
* 用于装饰当前组件的状态变量，`@Prop` 装饰变量发生变化时会驱动当前组件的视图进行刷新

> 此外，`@Prop` 装饰的变量还可以同步父组件中的状态变量，但只能单向同步，即父组件中的状态变化，会同步到子组件，但子组件的变化不会同步到父组件中
{: .prompt-info }


![image](/assets/img/harmony/prop.png)

> 如上图，当修改父组件 `@State` 时候子组件的 `@Prop` 也会发生变化。反之修改 子组件的 `@Prop`，父组件 `@State` 则不会发生变化
{: .prompt-info }

> Note: 声明 `@Prop` 时候是不能进行初始化的，只能通过父组件向子组件传参的方式进行初始化
{: .prompt-info }


```typescript
@Entry
@Component
struct Parent {
  @State count: number = 1

  build() {
    Column({ space: 50 }) {

      Column({ space: 10 }) {
        Text('父组件')

        // 父组件计时器
        Row({space: 10}) {
          Text('@State')

          Counter() {
            Text(this.count.toString())
          }
          .onInc(() => this.count++)
          .onDec(() => this.count--)
        }

        // 子组件
        Child({ count: this.count })
      }

    }
    .width('100%')
    .height('100%')
    .padding(20)   // 内边距，四边 20
    .justifyContent(FlexAlign.Center)

  }

}


// 子组件
@Component
struct Child {
  @Prop count: number;

  build() {
    Column({ space: 10 }) {

      Column({ space: 10 }) {
        Text('子组件')

        // 父组件计时器
        Row({ space: 10 }) {
          Text('@Prop')

          Counter() {
            Text(this.count.toString())
          }
          .onInc(() => this.count++)
          .onDec(() => this.count--)
        }

      }
    }
  }
}
```


### 3 `@Link`
* 用于装饰当前组件的状态变量，`@Link` 装饰变量发生变化时会驱动当前组件的视图进行刷新

> 如上图，当修改父组件 `@State` 时候子组件的 `@Link` 也会发生变化。反之修改 子组件的 `@Link`，父组件 `@State` 则也会发生变化
{: .prompt-info }


> Note: 声明 `@Link` 时候也不能进行初始化的，也只能通过父组件向子组件传参的方式进行初始化。并且父组件必须使用 `$变量名` 的方式传参，以表示传递的是变量的引用
{: .prompt-info }

![image](/assets/img/harmony/link.png)


```typescript
@Entry
@Component
struct Parent {
  @State count: number = 1

  build() {
    Column({ space: 50 }) {

      Column({ space: 10 }) {
        Text('父组件')

        // 父组件计时器
        Row({space: 10}) {
          Text('@State')

          Counter() {
            Text(this.count.toString())
          }
          .onInc(() => this.count++)
          .onDec(() => this.count--)
        }

        // 子组件，使用 $ 传参
        Child({ count: $count }) 
      }

    }
    .width('100%')
    .height('100%')
    .padding(20)   // 内边距，四边 20
    .justifyContent(FlexAlign.Center)

  }

}


// 子组件
@Component
struct Child {
  @Link count: number; // 声明

  build() {
    Column({ space: 10 }) {

      Column({ space: 10 }) {
        Text('子组件')

        // 父组件计时器
        Row({ space: 10 }) {
          Text('@Link')

          Counter() {
            Text(this.count.toString())
          }
          .onInc(() => this.count++)
          .onDec(() => this.count--)
        }

      }
    }
  }
}
```

### 4 `@Provide` 和 `@Consume`
* `@Provide` 和 `@Consume` 用于跨组件层级传递状态信息
* `@Provide` 用于装饰祖先组件的状态变量
* `@Consume` 用于装饰祖后代件的状态变量
* 可以理解为祖先组件提供（Provide）状态信息供后代组件（Consume），并且祖先和后代的状态信息可以实现双向同步


#### Note
* `@Provide` 装饰器必须进行本地初始化
* `@Consume` 装饰的变量不允许进行本地初始化

> `@Provide` 和 `@Consume` 不是通过父组件向子组件传参方式进行绑定的，`而是通过相同的变量名进行绑定的`
{: .prompt-info }


![image](/assets/img/harmony/provide.png)


#### 绑定
* 1 通过变量名：`@Provide count: number = 1` 和 `@Consume count: number;`
* 2 通过别名：`@Provide('count') parentCount: number = 1` 和 `@Consume('count') childCount: number;`


```typescript
@Entry
@Component
struct GrandParent {
  // 使用别名进行绑定
  @Provide('count') parentCount: number = 1

  build() {
    Column({ space: 50 }) {

      Column({ space: 10 }) {
        Text('祖先组件')

        // 祖先组件计时器
        Row({space: 10}) {
          Text('@Provide')

          Counter() {
            Text(this.parentCount.toString())
          }
          .onInc(() => this.parentCount++)
          .onDec(() => this.parentCount--)
        }

        // 父组件
        Parent()
      }

    }
    .width('100%')
    .height('100%')
    .padding(20)   // 内边距，四边 20
    .justifyContent(FlexAlign.Center)

  }

}


// 父组件
@Component
struct Parent {

  build() {
    Column({ space: 10 }) {

      Column({ space: 10 }) {
        Text('父亲组件')

        Divider()
          .strokeWidth(10)
          .color(Color.Pink)
          .height(2)

        Child()
      }
    }
  }
}

// 子组件
@Component
struct Child {
  // 使用别名进行绑定
  @Consume('count') childCount: number;

  build() {
    Column({ space: 10 }) {

      Column({ space: 10 }) {
        Text('子组件')

        // 父组件计时器
        Row({ space: 10 }) {
          Text('@Consume')

          Counter() {
            Text(this.childCount.toString())
          }
          .onInc(() => this.childCount++)
          .onDec(() => this.childCount--)
        }

      }
    }
  }
}
```
